// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package fulfillment

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strings"
)

// OperationsClient contains the methods for the FulfillmentOperations group.
// Don't use this type directly, use a constructor function instead.
type OperationsClient struct {
	internal *azcore.Client
	endpoint string
}

// ActivateSubscription - Use this call to activate a subscription.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2018-08-31
//   - options - OperationsClientActivateSubscriptionOptions contains the optional parameters for the OperationsClient.ActivateSubscription
//     method.
func (client *OperationsClient) ActivateSubscription(ctx context.Context, subscriptionID string, body SubscriberPlan, options *OperationsClientActivateSubscriptionOptions) (OperationsClientActivateSubscriptionResponse, error) {
	var err error
	req, err := client.activateSubscriptionCreateRequest(ctx, subscriptionID, body, options)
	if err != nil {
		return OperationsClientActivateSubscriptionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return OperationsClientActivateSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return OperationsClientActivateSubscriptionResponse{}, err
	}
	return OperationsClientActivateSubscriptionResponse{}, nil
}

// activateSubscriptionCreateRequest creates the ActivateSubscription request.
func (client *OperationsClient) activateSubscriptionCreateRequest(ctx context.Context, subscriptionID string, body SubscriberPlan, options *OperationsClientActivateSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/saas/subscriptions/{subscriptionId}/activate"
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.CorrelationID != nil {
		req.Raw().Header["x-ms-correlationid"] = []string{*options.CorrelationID}
	}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-requestid"] = []string{*options.RequestID}
	}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
	return nil, err
}
;	return req, nil
}

// DeleteSubscription - Unsubscribe and delete the specified subscription.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2018-08-31
//   - options - OperationsClientDeleteSubscriptionOptions contains the optional parameters for the OperationsClient.DeleteSubscription
//     method.
func (client *OperationsClient) DeleteSubscription(ctx context.Context, subscriptionID string, options *OperationsClientDeleteSubscriptionOptions) (OperationsClientDeleteSubscriptionResponse, error) {
	var err error
	req, err := client.deleteSubscriptionCreateRequest(ctx, subscriptionID, options)
	if err != nil {
		return OperationsClientDeleteSubscriptionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return OperationsClientDeleteSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return OperationsClientDeleteSubscriptionResponse{}, err
	}
	resp, err := client.deleteSubscriptionHandleResponse(httpResp)
	return resp, err
}

// deleteSubscriptionCreateRequest creates the DeleteSubscription request.
func (client *OperationsClient) deleteSubscriptionCreateRequest(ctx context.Context, subscriptionID string, options *OperationsClientDeleteSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/saas/subscriptions/{subscriptionId}"
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.CorrelationID != nil {
		req.Raw().Header["x-ms-correlationid"] = []string{*options.CorrelationID}
	}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-requestid"] = []string{*options.RequestID}
	}
	return req, nil
}

// deleteSubscriptionHandleResponse handles the DeleteSubscription response.
func (client *OperationsClient) deleteSubscriptionHandleResponse(resp *http.Response) (OperationsClientDeleteSubscriptionResponse, error) {
	result := OperationsClientDeleteSubscriptionResponse{}
	if val := resp.Header.Get("Operation-Location"); val != "" {
		result.OperationLocationURI = &val
	}
	return result, nil
}

// GetSubscription - Gets the specified SaaS subscription. Use this call to get license information and plan information.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2018-08-31
//   - options - OperationsClientGetSubscriptionOptions contains the optional parameters for the OperationsClient.GetSubscription
//     method.
func (client *OperationsClient) GetSubscription(ctx context.Context, subscriptionID string, options *OperationsClientGetSubscriptionOptions) (OperationsClientGetSubscriptionResponse, error) {
	var err error
	req, err := client.getSubscriptionCreateRequest(ctx, subscriptionID, options)
	if err != nil {
		return OperationsClientGetSubscriptionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return OperationsClientGetSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return OperationsClientGetSubscriptionResponse{}, err
	}
	resp, err := client.getSubscriptionHandleResponse(httpResp)
	return resp, err
}

// getSubscriptionCreateRequest creates the GetSubscription request.
func (client *OperationsClient) getSubscriptionCreateRequest(ctx context.Context, subscriptionID string, options *OperationsClientGetSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/saas/subscriptions/{subscriptionId}"
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.CorrelationID != nil {
		req.Raw().Header["x-ms-correlationid"] = []string{*options.CorrelationID}
	}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-requestid"] = []string{*options.RequestID}
	}
	return req, nil
}

// getSubscriptionHandleResponse handles the GetSubscription response.
func (client *OperationsClient) getSubscriptionHandleResponse(resp *http.Response) (OperationsClientGetSubscriptionResponse, error) {
	result := OperationsClientGetSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Subscription); err != nil {
		return OperationsClientGetSubscriptionResponse{}, err
	}
	return result, nil
}

// ListAvailablePlans - Use this call to find out if there are any private or public offers for the current publisher.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2018-08-31
//   - options - OperationsClientListAvailablePlansOptions contains the optional parameters for the OperationsClient.ListAvailablePlans
//     method.
func (client *OperationsClient) ListAvailablePlans(ctx context.Context, subscriptionID string, options *OperationsClientListAvailablePlansOptions) (OperationsClientListAvailablePlansResponse, error) {
	var err error
	req, err := client.listAvailablePlansCreateRequest(ctx, subscriptionID, options)
	if err != nil {
		return OperationsClientListAvailablePlansResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return OperationsClientListAvailablePlansResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return OperationsClientListAvailablePlansResponse{}, err
	}
	resp, err := client.listAvailablePlansHandleResponse(httpResp)
	return resp, err
}

// listAvailablePlansCreateRequest creates the ListAvailablePlans request.
func (client *OperationsClient) listAvailablePlansCreateRequest(ctx context.Context, subscriptionID string, options *OperationsClientListAvailablePlansOptions) (*policy.Request, error) {
	urlPath := "/saas/subscriptions/{subscriptionId}/listAvailablePlans"
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	if options != nil && options.PlanID != nil {
		reqQP.Set("planId", *options.PlanID)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.CorrelationID != nil {
		req.Raw().Header["x-ms-correlationid"] = []string{*options.CorrelationID}
	}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-requestid"] = []string{*options.RequestID}
	}
	return req, nil
}

// listAvailablePlansHandleResponse handles the ListAvailablePlans response.
func (client *OperationsClient) listAvailablePlansHandleResponse(resp *http.Response) (OperationsClientListAvailablePlansResponse, error) {
	result := OperationsClientListAvailablePlansResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SubscriptionPlans); err != nil {
		return OperationsClientListAvailablePlansResponse{}, err
	}
	return result, nil
}

// NewListSubscriptionsPager - Lists all the SaaS subscriptions for a publisher.
//
// Generated from API version 2018-08-31
//   - options - OperationsClientListSubscriptionsOptions contains the optional parameters for the OperationsClient.NewListSubscriptionsPager
//     method.
func (client *OperationsClient) NewListSubscriptionsPager(options *OperationsClientListSubscriptionsOptions) (*runtime.Pager[OperationsClientListSubscriptionsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[OperationsClientListSubscriptionsResponse]{
		More: func(page OperationsClientListSubscriptionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *OperationsClientListSubscriptionsResponse) (OperationsClientListSubscriptionsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSubscriptionsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return OperationsClientListSubscriptionsResponse{}, err
			}
			return client.listSubscriptionsHandleResponse(resp)
			},
	})
}

// listSubscriptionsCreateRequest creates the ListSubscriptions request.
func (client *OperationsClient) listSubscriptionsCreateRequest(ctx context.Context, options *OperationsClientListSubscriptionsOptions) (*policy.Request, error) {
	urlPath := "/saas/subscriptions/"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	if options != nil && options.ContinuationToken != nil {
		reqQP.Set("continuationToken", *options.ContinuationToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.CorrelationID != nil {
		req.Raw().Header["x-ms-correlationid"] = []string{*options.CorrelationID}
	}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-requestid"] = []string{*options.RequestID}
	}
	return req, nil
}

// listSubscriptionsHandleResponse handles the ListSubscriptions response.
func (client *OperationsClient) listSubscriptionsHandleResponse(resp *http.Response) (OperationsClientListSubscriptionsResponse, error) {
	result := OperationsClientListSubscriptionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SubscriptionsResponse); err != nil {
		return OperationsClientListSubscriptionsResponse{}, err
	}
	return result, nil
}

// Resolve - The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource
// ID is the unique identifier for a SaaS subscription. When a user is redirected to a
// partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make
// a request to resolve it. The response contains the unique SaaS subscription ID,
// name, offer ID, and plan for the resource. This token is valid for one hour only.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2018-08-31
//   - xmsMarketplaceToken - The token query parameter in the URL when the user is redirected to the SaaS partner's website from
//     Azure (for example, https://contoso.com/signup?token=..). Note, The URL decodes the token value from
//     the browser before using it.
//   - options - OperationsClientResolveOptions contains the optional parameters for the OperationsClient.Resolve method.
func (client *OperationsClient) Resolve(ctx context.Context, xmsMarketplaceToken string, options *OperationsClientResolveOptions) (OperationsClientResolveResponse, error) {
	var err error
	req, err := client.resolveCreateRequest(ctx, xmsMarketplaceToken, options)
	if err != nil {
		return OperationsClientResolveResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return OperationsClientResolveResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return OperationsClientResolveResponse{}, err
	}
	resp, err := client.resolveHandleResponse(httpResp)
	return resp, err
}

// resolveCreateRequest creates the Resolve request.
func (client *OperationsClient) resolveCreateRequest(ctx context.Context, xmsMarketplaceToken string, options *OperationsClientResolveOptions) (*policy.Request, error) {
	urlPath := "/saas/subscriptions/resolve"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.CorrelationID != nil {
		req.Raw().Header["x-ms-correlationid"] = []string{*options.CorrelationID}
	}
	req.Raw().Header["x-ms-marketplace-token"] = []string{xmsMarketplaceToken}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-requestid"] = []string{*options.RequestID}
	}
	return req, nil
}

// resolveHandleResponse handles the Resolve response.
func (client *OperationsClient) resolveHandleResponse(resp *http.Response) (OperationsClientResolveResponse, error) {
	result := OperationsClientResolveResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResolvedSubscription); err != nil {
		return OperationsClientResolveResponse{}, err
	}
	return result, nil
}

// UpdateSubscription - Use this call to update the plan, the user count (quantity), or both.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2018-08-31
//   - options - OperationsClientUpdateSubscriptionOptions contains the optional parameters for the OperationsClient.UpdateSubscription
//     method.
func (client *OperationsClient) UpdateSubscription(ctx context.Context, subscriptionID string, body SubscriberPlan, options *OperationsClientUpdateSubscriptionOptions) (OperationsClientUpdateSubscriptionResponse, error) {
	var err error
	req, err := client.updateSubscriptionCreateRequest(ctx, subscriptionID, body, options)
	if err != nil {
		return OperationsClientUpdateSubscriptionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return OperationsClientUpdateSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return OperationsClientUpdateSubscriptionResponse{}, err
	}
	resp, err := client.updateSubscriptionHandleResponse(httpResp)
	return resp, err
}

// updateSubscriptionCreateRequest creates the UpdateSubscription request.
func (client *OperationsClient) updateSubscriptionCreateRequest(ctx context.Context, subscriptionID string, body SubscriberPlan, options *OperationsClientUpdateSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/saas/subscriptions/{subscriptionId}"
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.CorrelationID != nil {
		req.Raw().Header["x-ms-correlationid"] = []string{*options.CorrelationID}
	}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-requestid"] = []string{*options.RequestID}
	}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
	return nil, err
}
;	return req, nil
}

// updateSubscriptionHandleResponse handles the UpdateSubscription response.
func (client *OperationsClient) updateSubscriptionHandleResponse(resp *http.Response) (OperationsClientUpdateSubscriptionResponse, error) {
	result := OperationsClientUpdateSubscriptionResponse{}
	if val := resp.Header.Get("Operation-Location"); val != "" {
		result.OperationLocationURI = &val
	}
	return result, nil
}

